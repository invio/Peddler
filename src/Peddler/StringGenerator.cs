using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Peddler {

    /// <summary>
    ///   A generator for non-nullable strings of various lengths and characters.
    /// </summary>
    public class StringGenerator : IDistinctGenerator<String> {

        private static ISet<Char> defaultCharacters { get; }
        private static StringComparer defaultComparer { get; }

        static StringGenerator() {
            defaultCharacters = CharacterSets.AsciiPrintable;
            defaultComparer = StringComparer.Ordinal;
        }

        private Random random { get; } = new Random();
        private char[] charactersLookup { get; }

        /// <summary>
        ///   The inclusive, lower boundary for the length of <see cref="String" />
        ///   instances created by this generator.
        /// </summary>
        public int Minimum { get; }

        /// <summary>
        ///   The inclusive, upper boundary for the length of <see cref="String" />
        ///   instances created by this generator.
        /// </summary>
        public int Maximum { get; }

        /// <summary>
        ///   The set of <see cref="Char" /> this <see cref="StringGenerator" />
        ///   will utilize from when creating instances of <see cref="String" />.
        /// </summary>
        public ISet<Char> Characters { get; }

        /// <inheritdoc />
        public IEqualityComparer<String> EqualityComparer { get; } = defaultComparer;

        /// <summary>
        ///   Instantiates a <see cref="StringGenerator" /> that can create
        ///   <see cref="String" /> instances with lengths that range from 0 to 255
        ///   characters (inclusively). The characters within the <see cref="String" />
        ///   will be of the <see cref="ISet{Char}" />
        ///   <see cref="CharacterSets.AsciiPrintable" />.
        /// </summary>
        public StringGenerator() :
            this(0, 255, defaultCharacters) {}

        /// <summary>
        ///   Instantiates a <see cref="StringGenerator" /> that can create
        ///   <see cref="String" /> instances with a length defined via the
        ///   <paramref name="length" /> parameter.  The characters within
        ///   the <see cref="String" /> will be of the <see cref="ISet{Char}" />
        ///   <see cref="CharacterSets.AsciiPrintable" />.
        /// </summary>
        /// <param name="length">
        ///   The length in characters of any <see cref="String" /> generated by this
        ///   <see cref="StringGenerator" />.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///   Thrown when the <paramref name="length" /> is less than 0.
        /// </exception>
        public StringGenerator(int length) :
            this(length, defaultCharacters) {}

        /// <summary>
        ///   Instantiates a <see cref="StringGenerator" /> that can create
        ///   <see cref="String" /> instances with a length defined via the
        ///   <paramref name="length" /> parameter. The characters within
        ///   the <see cref="String" /> are those provided via the
        ///   <paramref name="characters" /> parameter.
        /// </summary>
        /// <param name="length">
        ///   The length in characters of any <see cref="String" /> generated by this
        ///   <see cref="StringGenerator" />.
        /// </param>
        /// <param name="characters">
        ///   An explicit set of characters that this <see cref="StringGenerator" />
        ///   will use when it generates <see cref="String" /> instances.
        /// </param>
        /// <exception cref="ArgumentNullException">
        ///   Thrown when <paramref name="characters" /> is null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        ///   Thrown when the <paramref name="length" /> is less than 0.
        /// </exception>
        /// <exception cref="ArgumentException">
        ///   Thrown when the <paramref name="characters" /> set is empty, but the
        ///   <paramref name="length" /> is greater than 0.
        /// </exception>
        public StringGenerator(int length, ISet<Char> characters) {
            if (characters == null) {
                throw new ArgumentNullException(nameof(characters));
            }

            if (length < 0) {
                throw new ArgumentOutOfRangeException(
                    nameof(length),
                    $"The length ({length:N0}) was less than zero."
                );
            }

            if (!characters.Any() && length > 0) {
                throw new ArgumentException(
                    $"The '{nameof(characters)}' set is empty, " +
                    $"but the '{nameof(length)}' is greater than 0."
                );
            }

            this.Minimum = length;
            this.Maximum = length;
            this.Characters = characters.ToImmutableHashSet();
            this.charactersLookup = characters.ToArray();
        }

        /// <summary>
        ///   Instantiates a <see cref="StringGenerator" /> that can create
        ///   <see cref="String" /> instances with lengths that range from
        ///   <paramref name="minimum" /> to <paramref name="maximum" />
        ///   characters (inclusively). The characters within the <see cref="String" />
        ///   will be of the <see cref="ISet{Char}" />
        ///   <see cref="CharacterSets.AsciiPrintable" />.
        /// </summary>
        /// <param name="minimum">
        ///   The minimum length in characters of any <see cref="String" /> generated
        ///   by this <see cref="StringGenerator" />.
        /// </param>
        /// <param name="maximum">
        ///   The maximum length in characters of any <see cref="String" /> generated
        ///   by this <see cref="StringGenerator" />.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///   Thrown when the <paramref name="minimum" /> is less than 0.
        /// </exception>
        /// <exception cref="ArgumentException">
        ///   Thrown when the <paramref name="minimum" /> is greater than the
        ///   <paramref name="maximum" />.
        /// </exception>
        public StringGenerator(int minimum, int maximum) :
            this(minimum, maximum, defaultCharacters) {}

        /// <summary>
        ///   Instantiates a <see cref="StringGenerator" /> that can create
        ///   <see cref="String" /> instances with lengths that range from
        ///   <paramref name="minimum" /> to <paramref name="maximum" />
        ///   characters (inclusively). The characters within
        ///   the <see cref="String" /> are those provided via the
        ///   <paramref name="characters" /> parameter.
        /// </summary>
        /// <param name="minimum">
        ///   The minimum length in characters of any <see cref="String" /> generated
        ///   by this <see cref="StringGenerator" />.
        /// </param>
        /// <param name="maximum">
        ///   The maximum length in characters of any <see cref="String" /> generated
        ///   by this <see cref="StringGenerator" />.
        /// </param>
        /// <param name="characters">
        ///   An explicit set of characters that this <see cref="StringGenerator" />
        ///   will use when it generates <see cref="String" /> instances.
        /// </param>
        /// <exception cref="ArgumentNullException">
        ///   Thrown when <paramref name="characters" /> is null.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        ///   Thrown when the <paramref name="minimum" /> is less than 0.
        /// </exception>
        /// <exception cref="ArgumentException">
        ///   Thrown when the <paramref name="minimum" /> is greater than the
        ///   <paramref name="maximum" />.
        /// </exception>
        /// <exception cref="ArgumentException">
        ///   Thrown when the <paramref name="characters" /> set is empty, but the
        ///   <paramref name="maximum" /> is greater than 0.
        /// </exception>
        public StringGenerator(int minimum, int maximum, ISet<Char> characters) {
            if (characters == null) {
                throw new ArgumentNullException(nameof(characters));
            }

            if (minimum < 0) {
                throw new ArgumentOutOfRangeException(
                    nameof(minimum),
                    $"The minimum ({minimum:N0} was less than zero."
                );
            }

            if (maximum < minimum) {
                throw new ArgumentException(
                    $"The '{nameof(minimum)}' ({minimum:N0}) was not less than " +
                    $"the '{nameof(maximum)}' ({maximum:N0})."
                );
            }

            if (!characters.Any() && maximum > 0) {
                throw new ArgumentException(
                    $"The '{nameof(characters)}' set is empty, " +
                    $"but the '{nameof(maximum)}' is greater than 0."
                );
            }

            this.Minimum = minimum;
            this.Maximum = maximum;
            this.Characters = characters.ToImmutableHashSet();
            this.charactersLookup = characters.ToArray();
        }

        private int NextInt32Inclusive(int low, int high) {
            return (Int32)this.random.NextInt64(low, (Int64)(high + 1));
        }

        private String NextOfLength(int length) {
            var buffer = new StringBuilder(length);

            for (var character = 0; character < length; character++) {
                var index = this.random.Next(this.charactersLookup.Length);

                buffer.Append(this.charactersLookup[index]);
            }

            return buffer.ToString();
        }

        /// <summary>
        ///   Creates a random <see cref="String" /> with a length that ranges
        ///   from <see cref="Minimum" /> to <see cref="Maximum" /> utilizing
        ///   the characters defined in the <see cref="Characters" /> set.
        /// </summary>
        /// <returns>
        ///   A non-null string with a length that ranges from
        ///   <see cref="Minimum" /> to <see cref="Maximum" /> utilizing
        ///   the characters defined in the <see cref="Characters" /> set.
        /// </returns>
        public String Next() {
            var length = this.NextInt32Inclusive(this.Minimum, this.Maximum);

            return this.NextOfLength(length);
        }

        /// <summary>
        ///   Creates a new <see cref="String" /> instance that is distinct from
        ///   the <paramref name="other" />, but will still have a length that is between
        ///   <see cref="Minimum" /> and <see cref="Maximum" /> (inclusively), and only
        ///   contain characters defined in the <see cref="Characters" /> property.
        /// </summary>
        /// <remarks>
        ///   The <see cref="String" /> provided for <paramref name="other" /> does not,
        ///   itself need to have a length between defined <see cref="Minimum" /> and
        ///   <see cref="Maximum" />, nor only contain characters defined in the
        ///   <see cref="Characters" /> property.
        /// </remarks>
        /// <param name="other">
        ///   A <see cref="String" /> that is distinct (in terms of characters or length)
        ///   from the <see cref="String" /> that is returned.
        /// </param>
        /// <returns>
        ///   A <see cref="String" /> that is distinct (in terms of characters or length)
        ///   from <paramref name="other" />, has a length that is between
        ///   <see cref="Minimum" /> and <see cref="Maximum" /> (inclusively), and contains
        ///   characters defined in the <see cref="Characters" /> property.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        ///   Thrown when <paramref name="other" /> is null.
        /// </exception>
        /// <exception cref="UnableToGenerateValueException">
        ///   Thrown when this generator is unable to provide a <see cref="String" /> that
        ///   is distinct from the value provided via the <paramref name="other" /> argument.
        ///   This can happen if <see cref="Minimum" /> and <see cref="Maximum" /> are
        ///   equal to the length of <paramref name="other" /> and the characters that
        ///   <paramref name="other" /> are each considered equal to all of the characters
        ///   defined in this <see cref="StringGenerator" /> instances' the
        ///   <see cref="Characters" /> property.
        /// </exception>
        public String NextDistinct(String other) {
            if (other == null || other.Length < this.Minimum || other.Length > this.Maximum) {

                // In this context, we couldn't generate a matching string if we wanted to,

                return this.Next();
            }

            var nextPossiblyDistinctIndex = this.GetNextIndexWithDistinctPossibility(other);

            if (nextPossiblyDistinctIndex == -1) {

                // We cannot generate a string that is unique based upon its characters.
                // We can only generate a string that is unique based upon its length.
                // This leaves a branch with two options, (A) and (B)

                // (A) If this StringGenerator is set with a constant length that is
                // equal to the length of the 'other' string, we cannot generate a
                // unique value and must throw an UnableToGeneratevalueException.

                if (this.Minimum == this.Maximum && this.Minimum == other.Length) {
                    throw new UnableToGenerateValueException(
                        $"Unable to provide a {typeof(String).Name} that is distinct " +
                        $"from an '{nameof(other)}' of '{other}'.",
                        nameof(other)
                    );
                }

                // (B) If this StringGenerator is not set with a constant length, we can
                // generate a possible length that is our range - 1. If the length we
                // generate is equal to the length of the 'other' string, add one.
                // This guarantees the new string does not have the same length as
                // the 'other' provided string.

                var nextLength = this.NextInt32Inclusive(this.Minimum, this.Maximum - 1);

                if (nextLength >= other.Length) {
                    nextLength++;
                }

                return this.NextOfLength(nextLength);
            }

            // Easy case. If we randomly chose a length that is different than the
            // length of the 'other' provided string, generate a string of that length.

            var length = this.NextInt32Inclusive(this.Minimum, this.Maximum);

            if (length != other.Length) {
                return this.NextOfLength(length);
            }

            // Harder case. If we randomly chose a length that is equal than the length
            // of the 'other' provided string, we have to specifically aim for a specific
            // character discrepency.

            var buffer = new StringBuilder(length);
            var isDistinct = false;

            for (var index = 0; index < length; index++) {
                char[] lookup = this.charactersLookup;

                if (!isDistinct && nextPossiblyDistinctIndex == index) {
                    nextPossiblyDistinctIndex =
                        this.GetNextIndexWithDistinctPossibility(other, index);

                    if (nextPossiblyDistinctIndex == -1) {
                        // This is the last possible character that can be distinct.
                        // Therefore, we will force it to be distinct by removing
                        // all matching characters from the parent set.

                        lookup = this.Characters.Where(c => c != other[index]).ToArray();
                    }
                }

                buffer.Append(lookup[this.random.Next(lookup.Length)]);
                isDistinct = isDistinct || buffer[index] != other[index];
            }

            return buffer.ToString();
        }

        private int GetNextIndexWithDistinctPossibility(string other, int currentIndex = -1) {
            for (var index = currentIndex + 1; index < other.Length; index++) {
                if (this.Characters.Any(c => c != other[index])) {
                    return index;
                }
            }

            return -1;
        }

    }



}
